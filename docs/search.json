[
  {
    "objectID": "0451-shiny_phq.html",
    "href": "0451-shiny_phq.html",
    "title": "7  Shiny for questionnaire of PHQ-9",
    "section": "",
    "text": "In this chapter, I will discuss about the PHQ-9 and shiny apps. \n\nPHQ-9\n\nThe Patient Health Questionnaire-9 (PHQ-9) is a self-report questionnaire used to screen for major depressive disorder (MDD). It is a nine-item questionnaire that asks about symptoms of depression such as depressed mood, loss of interest or pleasure, changes in sleep, changes in appetite, changes in energy, difficulty concentrating, worthlessness or excessive guilt, thoughts of death or suicide, and psychomotor agitation or retardation. The PHQ-9 is scored on a scale of 0 to 27, with higher scores indicating more severe depression. A score of 10 or more is considered to be positive for MDD.\nfor questionnaire, the url is following.\nhttps://med.stanford.edu/fastlab/research/imapp/msrs/_jcr_content/main/accordion/accordion_content3/download_256324296/file.res/PHQ9%20id%20date%2008.03.pdf \n\n\n\n\nHere are the guidelines for each score on the PHQ-9:\n\n\n\n\n\n\n\n\n\nScore\nseverity\nGuideline\n\n\n\n\n0-4\nMinimal depression\nYou may have some mild symptoms of depression, but they are not severe enough to interfere with your daily life.\n\n\n5-9\nMild depression\nYou may have some moderate symptoms of depression, and they may be interfering with your daily life to some extent.\n\n\n10-14\nModerate depression\nYou may have some severe symptoms of depression, and they are interfering with your daily life to a significant extent.\n\n\n15-19\nModerately severe depression\nYou may have some very severe symptoms of depression, and they are interfering with your daily life to a great extent.\n\n\n20-27\nSevere depression\nYou may have some extremely severe symptoms of depression, and they are interfering with your daily life to a very great extent.\n\n\n\n\n\nLet’s begin by creating a basic template for Shiny applications.\n\nThis template will serve as a foundation for us to build upon as we develop interactive web applications using the Shiny package in R. Our starting point will be the essential UI and server components, ensuring a seamless structure to organize our application’s functionality and presentation\n\n\nui = fluidPage(…): The ui object defines the user interface of the Shiny app. fluidPage is a layout function that creates a page with fluid layout. Fluid layout means that the layout of your page will adjust to the size of the browser window, so it’s responsive and works well on both desktops and mobile devices.\ntabsetPanel(…): This function creates a tabbed panel in the user interface, allowing users to switch between different tabs within the application. It’s a good way to organize content that’s divided into different categories or sections.\ntabPanel(“Questionnaire”): This is the first tab in the tabbed panel. It creates a tab with the title “Questionnaire”. The content of the tab (which is not shown in your snippet) would be defined within this tabPanel function.\ntabPanel(“Results”): Similarly, this creates a second tab titled “Results”. This tab would typically be used to display the results of the questionnaire or any other outputs or visualizations that your app produces based on the user input.\n\n\nNow, let’s creates a fluid page with a single tab panel containing a questionnaire based on the Patient Health Questionnaire-9 (PHQ-9)\n\n\n\n\nui = fluidPage(\n  tabsetPanel(\n    tabPanel(\"Questionnaire\", \n             fluidRow(\n               br(),\n              column(12, \"PHQ-9\", \n                     fluidRow(\n                     column(5, \"Questionnaire\"), \n                     column(7, \"Scores\")\n                     ))), \n             fluidRow(\n              column(12, \"\",\n               fluidRow(\n                       column(5, \"Little interest or pleasure in doing things\"), \n                       column(7, radioButtons(\"phq1\", \"\",\n                                              choiceNames = c('Not at all',\n                                                              'Several',\n                                                              'More than half',\n                                                              'Nearly every'\n                                              ), \n                                              choiceValues = c(0,1, 2, 3),\n                                              inline = TRUE))\n                     )\n              )), \n             actionButton(\"submit_depression\", \"Submit!\"),\n             htmlOutput(\"depression\")\n             ) \n  )"
  },
  {
    "objectID": "0461-shiny_html.html",
    "href": "0461-shiny_html.html",
    "title": "8  Shiny and HTML and javascript",
    "section": "",
    "text": "Integrating HTML and JavaScript into Shiny apps is important for several key reasons:\n1. Enhanced Customization\n\nFine-Grained Control: While Shiny provides a solid set of UI components, HTML gives you absolute control over the structure and arrangement of elements. You can build layouts and components precisely as you envision them.\nUnique Styling: CSS allows you to style every aspect of your app’s appearance. Go beyond Shiny’s default styling to establish a distinct visual identity that matches your branding or needs.\nAdvanced Visuals: Integrate external JavaScript charting libraries (D3.js, Plotly.js, Leaflet, etc.) to create highly interactive and customizable visualizations that go beyond what Shiny offers out of the box.\n\n2. Unlocking Interactivity\n\nDynamic Behavior: JavaScript empowers you to modify the UI directly in response to user actions. Create elements that appear/disappear, animations, and seamless user experiences without full page refreshes. Complex Input Handling: Use JavaScript for custom input validation that goes beyond Shiny’s basic checks (e.g., real-time field validation, complex form logic).\nExternal Library Integration: Tap into the vast world of JavaScript libraries for specialized UI widgets, interactive elements, and functionality that extends Shiny’s capabilities.\n\n3. Bridging the Gap\n\nLeveraging Web Development Skills: If you or your team have HTML, CSS, and JavaScript expertise, you can directly apply these skills within your Shiny apps.\nReusing Existing Components: Integrate pre-existing HTML templates or JavaScript components you might already have, saving development time. Example Scenarios\nCustom Dashboard: Build a highly tailored dashboard interface with a specific grid layout, custom styling, and interactive visualizations using a charting library.\nResponsive Layouts: Design Shiny apps that adapt seamlessly to different screen sizes, a feature that can be more easily achieved using HTML/CSS techniques.\nInteractive Map: Embed a map from Leaflet allowing users to zoom, pan, and interact with data markers in ways not directly supported by standard Shiny components.\n\n4. Let’s be mindful:\n\nTrade-off: Too much reliance on raw HTML/JS can increase code complexity and potentially add to maintenance overhead. It’s best to use it strategically where Shiny’s built-in features don’t fully meet your needs.\nShinyJS: The shinyjs package in R provides useful functions to make standard JavaScript interactions easier within the Shiny framework.\n\n\nui &lt;- fluidPage(\n\n  # Page Title \n  h2(\"Night Shift Comprehensive Questionnaire [Part 1]\"), \n\n  # Basic Input Fields\n  fluidRow(\n    column(4, textInput(\"compname\", \"Company Name: \", \"\")),\n    column(4, dateInput(\"birthyear\", \"Date of Birth: \")),\n    column(4, textInput(\"name\", \"Name: \", \"\"))\n  ),\n\n  # Main Questionnaire Area\n  h4(\"Please describe any past medical conditions:\"),\n  textAreaInput(\"past_history\", \"\", rows = 3),\n\n  # Submit Button\n  actionButton(\"save1\", \"Save\") \n)"
  },
  {
    "objectID": "0461-shiny_html.html#why-we-use-htm-and-javascript-into-shiny-apps",
    "href": "0461-shiny_html.html#why-we-use-htm-and-javascript-into-shiny-apps",
    "title": "8  Shiny and HTML and javascript",
    "section": "8.1 Why we use HTM and JavaScript into Shiny apps",
    "text": "8.1 Why we use HTM and JavaScript into Shiny apps\nIntegrating HTML and JavaScript into Shiny apps is important for several key reasons:\n1. Enhanced Customization\n\nFine-Grained Control: While Shiny provides a solid set of UI components, HTML gives you absolute control over the structure and arrangement of elements. You can build layouts and components precisely as you envision them.\nUnique Styling: CSS allows you to style every aspect of your app’s appearance. Go beyond Shiny’s default styling to establish a distinct visual identity that matches your branding or needs.\nAdvanced Visuals: Integrate external JavaScript charting libraries (D3.js, Plotly.js, Leaflet, etc.) to create highly interactive and customizable visualizations that go beyond what Shiny offers out of the box.\n\n2. Unlocking Interactivity\n\nDynamic Behavior: JavaScript empowers you to modify the UI directly in response to user actions. Create elements that appear/disappear, animations, and seamless user experiences without full page refreshes. Complex Input Handling: Use JavaScript for custom input validation that goes beyond Shiny’s basic checks (e.g., real-time field validation, complex form logic).\nExternal Library Integration: Tap into the vast world of JavaScript libraries for specialized UI widgets, interactive elements, and functionality that extends Shiny’s capabilities.\n\n3. Bridging the Gap\n\nLeveraging Web Development Skills: If you or your team have HTML, CSS, and JavaScript expertise, you can directly apply these skills within your Shiny apps.\nReusing Existing Components: Integrate pre-existing HTML templates or JavaScript components you might already have, saving development time. Example Scenarios\nCustom Dashboard: Build a highly tailored dashboard interface with a specific grid layout, custom styling, and interactive visualizations using a charting library.\nResponsive Layouts: Design Shiny apps that adapt seamlessly to different screen sizes, a feature that can be more easily achieved using HTML/CSS techniques.\nInteractive Map: Embed a map from Leaflet allowing users to zoom, pan, and interact with data markers in ways not directly supported by standard Shiny components.\n\n4. Let’s be mindful:\n\nTrade-off: Too much reliance on raw HTML/JS can increase code complexity and potentially add to maintenance overhead. It’s best to use it strategically where Shiny’s built-in features don’t fully meet your needs.\nShinyJS: The shinyjs package in R provides useful functions to make standard JavaScript interactions easier within the Shiny framework."
  },
  {
    "objectID": "0461-shiny_html.html#how-to-use-html-tags-custom-css-and-js",
    "href": "0461-shiny_html.html#how-to-use-html-tags-custom-css-and-js",
    "title": "8  Shiny and HTML and javascript",
    "section": "8.2 How to use html tags, custom css and js",
    "text": "8.2 How to use html tags, custom css and js\nHere is basic shiny app structure,\n\nui &lt;- fluidPage(\n\n  # Page Title \n  \"Night Shift Comprehensive Questionnaire [Part 1]\", \n\n  # Basic Input Fields\n  fluidRow(\n    column(4, textInput(\"compname\", \"Company Name: \", \"\")),\n    column(4, dateInput(\"birthyear\", \"Date of Birth: \")),\n    column(4, textInput(\"name\", \"Name: \", \"\"))\n  ),\n\n  # Main Questionnaire Area\n  \"Please describe any past medical conditions:\",\n  textAreaInput(\"past_history\", \"\", rows = 3),\n\n  # Submit Button\n  actionButton(\"save1\", \"Save\") \n)\n\n\n\n8.2.1 HTM tags\nHere’s a breakdown of the basic HTML tags you can use within your Shiny application, along with how they work and common use cases:\nStructural Tags\n\ndiv A generic container used to group elements and apply styles. It’s great for creating sections or layout blocks.\nspan An inline container used to style a portion of text or other inline elements.\np Defines a paragraph of text.\nh1 to h6 Different heading levels (h1 being the largest, h6 the smallest).\nbr Creates a line break.\n\nFormatting Tags\n\nstrong Makes text bold.\nem Emphasizes text with italics.\na Creates a hyperlink (use the href attribute to set the link destination).\n\nLists\n\nul Unordered list (bullet points).\nol Ordered list (numbered).\nli A list item, used within ul or ol.\n\nTables\n\ntable Represents tabular data.\nthead Table header.\ntbody Table body.\ntr Table row.\nth Table header cell.\ntd Table data cell.\n\n\nHow to Use Them in Shiny\n\n\nShiny’s tags Object: Most common HTML tags are available as functions in Shiny’s tags object. Example:\n\n\ntags$h3(\"Section Title\"),  \ntags$p(\"This is a paragraph of text.\") \n\n\nRaw HTML with HTML(): For inserting any HTML structure:\n\n\nHTML('&lt;div style=\"background-color: lightblue;\"&gt;Custom Content&lt;/div&gt;')\n\n\nCustom Layouts: Use div elements with CSS styling to create flexible grid or column-based layouts.\n\n\nEnhanced Text: Add emphasis, links, and line breaks within outputs.\nBasic Tables: Display structured data within your Shiny app.\n\n\nImportant Notes\n\n\nCSS: Always consider combining HTML tags with CSS (either internal stylesheets or an external .css file) for precise visual control.\nNesting: Ensure proper tag nesting (e.g., li elements should be within ul or ol).\n\n\n\n8.2.2 Tutorial of HTML code anc CSS in shiny\nThis code demonstrates the integration of HTML tags, raw HTML, and CSS styling to create the basic structure of a Shiny web application.\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$style(\n      \"\n      .h3-center {\n      text-align: center;\n      font-weight: bold;\n      }\n    \")\n  ),\n  # Page Title \n  tags$h3(\"Night Shift Comprehensive Questionnaire [Part 1]\", class=\"h3-center\"), \n  tags$h3(\"Night Shift Comprehensive Questionnaire [Part 1]\"),\n  h3(\"Night Shift Comprehensive Questionnaire [Part 1]\", style=\"text-align: center;font-weight: bold;\"),\n  HTML('&lt;h3&gt;Night Shift Comprehensive Questionnaire [Part 1]&lt;/h3&gt;'),\n  # Basic Input Fields\n  fluidRow(\n    column(4, textInput(\"compname\", \"Company Name: \", \"\")),\n    column(4, dateInput(\"birthyear\", \"Date of Birth: \")),\n    column(4, textInput(\"name\", \"Name: \", \"\"))\n  ),\n  \n  # Main Questionnaire Area\n  HTML(\"Please describe any past  medical conditions:\"),\n  textAreaInput(\"past_history\", \"\", rows = 3),\n  \n  # Submit Button\n  actionButton(\"save1\", \"Save\") \n)\n\n\nCSS Styling\n\n\ntags$head: This section is dedicated to elements that go into the\n\nof your HTML document.\ntags$style: This function is used to embed CSS styles directly within your Shiny app.\n.h3-center Class: You’ve defined a CSS class with the following properties:\n\ntext-align: center: Centers the text horizontally.\nfont-weight: bold : Makes the text bold.\n\n\n\nPage Title Variations\n\nYou have several ways of creating the page title “Night Shift Comprehensive Questionnaire [Part 1]”. Let’s look at each:\n\ntags$h3 with Class:\n\n\ntags$h3(\"Night Shift Comprehensive Questionnaire [Part 1]\", class=\"h3-center\")\n\nThis utilizes Shiny’s built-in h3 function and applies the h3-center class to style it.\n\nh3 with Inline Style:\n\n\nh3(\"Night Shift Comprehensive Questionnaire [Part 1]\", style=\"text-align: center;font-weight: bold;\") \n\nThis creates the h3 element directly and sets the styles inline.\n\nHTML() with &lt;h3&gt;:\n\n\nHTML('&lt;h3&gt;Night Shift Comprehensive Questionnaire [Part 1]&lt;/h3&gt;') \n\nThis inserts the raw HTML equivalent of an &lt;h3&gt; tag into the UI.\n\ncustom style\n\nHere’s how to define multiple CSS classes within a Shiny app, with examples for customizing headers and form elements.\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$style(\n      \"\n      .h3-center {\n      text-align: center;\n      font-weight: bold;\n      }\n      .table-like {\n      border: 1px solid #ff4d4d; /* Color of your table border */\n      background-color: #e6f2ff; /* Light blue background for input fields */\n      border-radius: 5px; /* Rounded corners for the 'table' */\n      } \n    \")\n  ),\n # Page Title \n h3(\"Night Shift Comprehensive Questionnaire [Part 1]\", class=\"h3-center\"), \n div(class=\"table-like\", \n  # Basic Input Fields\n  fluidRow(\n    column(4, textInput(\"compname\", \"Company Name: \", \"\")),\n    column(4, dateInput(\"birthyear\", \"Date of Birth: \")),\n    column(4, textInput(\"name\", \"Name: \", \"\"))\n  )),\n  \n  # Main Questionnaire Area\n  HTML(\"Please describe any past  medical conditions:\"),\n  textAreaInput(\"past_history\", \"\", rows = 3),\n  \n  # Submit Button\n  actionButton(\"save1\", \"Save\") \n)\n\nThe class=“table-like” in the provided code is a way to apply a CSS class to a specific HTML element (a div element in this case).\n\nLet’s break it down:\n\n\nclass Attribute: This is a standard HTML attribute used to assign CSS classes to elements.\ntable-like: This is the name you’ve chosen for the CSS class. It identifies a set of styling rules defined elsewhere (within the tags$style section of your UI code).\ndiv Element: The div element acts as a container. By assigning the class=“table-like” to this div, you’re applying those styles to everything within that container (in this case, the entire row of input fields).\n\n\nExplanation of the .table-like CSS Class\n\nThe actual functionality is defined within the CSS stylesheet (tags$style section) under the class .table-like. Here’s what each property does:\n\nborder: 1px solid #ff4d4d: Creates a solid 1-pixel border around the element with the color #ff4d4d (most likely a shade of red).\nbackground-color: #e6f2ff: Sets the background color within the element to a light blue shade (#e6f2ff).\nborder-radius: 5px: Adds rounded corners to the element with a radius of 5 pixels.\n\n\nOverall Effect\n\nBy applying the table-like class, you’re visually grouping the input fields and giving them a table-like appearance with a border, background color, and rounded corners.\n\nUsing Custom style.css file\n\nInstead of embedding CSS directy with ‘tags$style’,\n\ntags$head(\n    tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"styles.css\"),\n  )\n\nUsing tags$link to reference an external CSS file (styles.css in www directory) generally offers several advantages over embedding CSS directly with tags$style:\n1). Maintainability\n\nSeparation of Concerns: CSS rules exist within their own .css file, keeping your Shiny UI code focused on structure and less cluttered with styling.\nEasier Editing: Large or complex CSS stylesheets are easier to modify and manage in a dedicated file using suitable text editors or IDEs.\nReusability: The same styles.css can be linked to multiple Shiny UI files, promoting consistent styling across your applications.\n\n2). Readability\n\nCleaner UI Code: Your Shiny UI code (ui.R file) becomes less crowded, making it easier to focus on the overall structure of the application.\nFamiliar Syntax: For those comfortable with CSS, working within a .css file is typically more intuitive than having tags$style blocks in your Shiny R code.\n\n3). Performance Considerations\n\nCaching: Browsers can cache external stylesheets, potentially leading to faster loading times on subsequent visits to your Shiny application.\n\n4). When Inline Styling Might Be Used\n\nSmall Tweaks: If you have very minimal CSS changes (affecting only one or two elements), then tags$style might be suitable for convenience.\nDynamic Styling: If you need to generate CSS rules based on calculations or user input within Shiny, using tags$style alongside Shiny’s reactivity can be necessary.\n\n5). Best Practice\nFor most projects, using tags$link to reference external CSS is considered the best practice due to its benefits in maintainability, readability, and structure."
  },
  {
    "objectID": "0461-shiny_html.html#using-javascript-in-shiny",
    "href": "0461-shiny_html.html#using-javascript-in-shiny",
    "title": "8  Shiny and HTML and javascript",
    "section": "8.3 Using JavaScript in Shiny",
    "text": "8.3 Using JavaScript in Shiny\nHere are ui, server, global files and app.js\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(href=\"https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap\", rel=\"stylesheet\"),\n    tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"styles.css\"),\n    tags$script(src=\"app.js\")\n  ),\n # Page Title \n h3(\"Night Shift Comprehensive Questionnaire [Part 1]\", class=\"h3-center\"), \n div(class=\"table-like\", \n  # Basic Input Fields\n  fluidRow(\n    column(4, textInput(\"compname\", \"Company Name: \", \"\")),\n    column(4, dateInput(\"birthyear\", \"Date of Birth: \")),\n    column(4, textInput(\"name\", \"Name: \", \"\"))\n  )),\n  # Main Questionnaire Area\n HTML(\"Please describe any past  medical conditions:\"),\n textAreaInput(\"past_history\", \"\", rows = 3),\n  \n hr(),\n h4(\"&gt;&gt; Sleep Disorders (Insomnia Index)\"),\n h5(\"1~3. Please indicate how severe the problems in each of the following items have been in the past 2 weeks.\", style=\"font-weight: bold;margin-left:5px;\"),\n DT::dataTableOutput('input_table_sleep_1'),\n br(),\n  # Submit Button\n  actionButton(\"save1\", \"Save\") \n)\n\nfor UI, \n\nPlaceholder: The line DT::dataTableOutput('input_table_sleep_1') acts as a placeholder within your user interface. It signals to Shiny, “Reserve a space here – I’ll dynamically populate it with a data table later.”\nOutput ID: The ‘input_table_sleep_1’ is a crucial identifier. It allows the Shiny server to target this specific element to insert the generated table content\n\n\nserver= function(input, output, session){\n  output$input_table_sleep_1 &lt;- DT::renderDataTable(\n    q1m, escape = FALSE, selection = 'none', server = FALSE,\n    options = list(dom = 't', paging = FALSE, ordering = FALSE), \n    class = 'cell-border stripe'\n  )\n  \n}\n\nfor server \nLet’s break down what happens within this renderDataTable section:\n\nData Source: You provide q1m as the data that will make up your table’s content. Remember, q1m is the HTML matrix generated by your generate_html function, containing the structure of survey questions and the radio button inputs.\nescape = FALSE: Tells Shiny to render the HTML from q1m directly, so your radio button survey inputs appear correctly.\nselection, paging, ordering: These control table features. You’ve disabled selection, pagination, and ordering for simplicity.\nclass: Applies CSS classes for visual styling of your table.\n\nKey Function: The DT::renderDataTable() is the workhorse that takes the HTML structure, combines it with styling options, and transforms it into a proper interactive DataTable to be displayed within the UI placeholder.\n\nlibrary(shinyalert)\nlibrary(shiny)\nlibrary(DT)\nlibrary(shinyWidgets)\nlibrary(tidyverse)\n\n# Question codes\nq1_code &lt;- c(\"slp_q1\", \"slp_q2\", \"slp_q3\")\nq1_source &lt;- c(\"1. Difficulty falling asleep\", \"2. Difficulty staying asleep\", \"3. Waking up too early\")\n\n# Answer option codes\nopt1_code &lt;- c(\"opt1_1\", \"opt1_2\", \"opt1_3\", \"opt1_4\", \"opt1_5\")\nopt1_source &lt;- c(\"None\", \"Slightly\", \"Moderately\", \"Severely\", \"Very&lt;br&gt;Severely\")\nopt1_value &lt;- c(0, 1, 2, 3, 4)\n\n\n\ngenerate_html &lt;- function(q_code, q_source, opt_value, opt_source) {\n  html_matrix &lt;- sapply(q_code, function(code) {\n    sapply(opt_value, function(value) {\n      sprintf('&lt;input type=\"radio\" class=\"my-radio-button\" id=\"%s-%d\" name=\"%s\" value=\"%d\"/&gt;', \n              code, value, code, value)\n    }, USE.NAMES = FALSE)\n  }, USE.NAMES = FALSE)\n  html_matrix &lt;- matrix(unlist(html_matrix), nrow = length(q_code), byrow = TRUE)\n  rownames(html_matrix) &lt;- q_source\n  colnames(html_matrix) &lt;- opt_source\n  return(html_matrix)\n}\n\n# Use the function to generate your HTML matrix\nq1m &lt;- generate_html(q1_code,q1_source,opt1_value,opt1_source)\n\nLet’s break down the code step-by-step to understand its purpose in generating a survey questionnaire.\ngenerate_html Function\n\nPurpose: The core of the code. It dynamically creates the HTML structure required for radio-button style survey questions.\nLogic:\n\nIt takes the provided question and option data as input.\nUses nested sapply loops to iterate through questions and answer options.\nThe sprintf function carefully formats HTML strings for each radio button, embedding codes, names, and values for later use in Shiny.\nIt organizes the generated HTML into a matrix for convenient structure, with rows representing questions and columns representing answer choices.\n\n\nGenerating Input Matrix\n\nq1m &lt;- generate_html(...): Here, the generate_html function is called with the survey data. The resulting HTML matrix is stored in the q1m variable.\n\nHow It Works in Shiny\nWhile this code snippet doesn’t represent a complete Shiny app, here’s how it likely fits into the bigger picture:\n\nUI Definition: In your Shiny UI, you’d use functions like htmlOutput() or potentially DT::datatable() to insert the contents of the q1m variable into your app’s layout, rendering the survey questions.\nServer Logic: The Shiny server would handle user selections from the radio buttons. This would involve accessing the values of the selected inputs, which can then be processed, stored, or used to trigger other actions in your app.\n\n\n// app.js\n$(document).ready(function() {\n  console.log(\"Document ready and script loaded.\"); // Debug log\n\n  $(document).on('change', '.my-radio-button', function() {\n    var name = $(this).attr('name');\n    var value = $(this).val();\n    console.log(\"Radio button changed:\", name, value); // Debug log\n    Shiny.setInputValue(name, value);\n  });\n});\n\nThe JavaScript Connection (app.js) \nThe JavaScript code plays a vital role connecting user actions on the survey radio buttons to Shiny’s reactivity:\n\n$(document).on('change', '.my-radio-button', function() { ... });: This listens for “change” events on any elements with the class my-radio-button (which your radio buttons have).\nShiny.setInputValue(name, value);: The key line! It tells Shiny to update an input variable with the name and value of the selected radio button. This triggers Shiny’s reactivity, potentially causing other parts of your app to update.\n\nstyle.css is following.\n\n\n.gowun-dodum-regular {\n        font-family: 'Gowun Dodum', sans-serif;\n        font-weight: 400;\n        font-style: normal;\n      }\n      \nbody {\n        font-family: 'Gowun Dodum', sans-serif;\n}\n\n.h3-center {\n  text-align: center;\n  font-weight: bold;\n}\n.input-row {\n        padding: 5px 0;\n      }\n.shiny-input-container {\n  padding: 0 5px;\n}\n.shiny-input-container&gt;label {\n  font-weight: bold;\n}\n.shiny-input-radio&gt;label {\n  font-weight: normal;\n}\n\n.table-like {\n  border: 1px solid #ff4d4d; /* Color of your table border */\n  background-color: #e6f2ff; /* Light blue background for input fields */\n  border-radius: 5px; /* Rounded corners for the 'table' */\n}\n.table-header {\n  background-color: #ff4d4d; /* Red background for headers */\n  color: white; /* Text color for headers */\n  text-align: center;\n  border-radius: 5px 5px 0 0; /* Rounded corners for header */\n  padding: 5px;\n  margin-bottom: 0; /* Remove bottom margin from headers */\n}\n.inline label{\n  display: table-cell; text-align: left; vertical-align: middle; \n} \n.inline .form-group{display: table-row;}\n\n\n.input-large {\n  width: 100%;\n  max-width: 100%;\n  height: 150px;\n}\n.form-title {\n  background-color: #e9ecef;\n  padding: 10px;\n  font-weight: bold;\n  #border-top: 2px solid #0275d8;\n  #border-bottom: 2px solid #0275d8;\n  margin-bottom: 20px;\n}\n\n.vertical-align-middle {\n        display: inline-block;\n        vertical-align: middle;\n}\n\n.inline-radio-group .shiny-input-radio {\n        display: inline-block;\n        vertical-align: top;\n        margin-right: 5px;\n}\n.inline-radio-group label {\n  display: inline-block;\n  margin-right: 20px;\n}\n.inline-radio-group .form-group {\n  margin-bottom: 0;\n}\n.shiny-input-container {\n  clear: both;\n  padding-top: 5px;\n}\n\ntable.dataTable thead th {\n  background-color: #e9ecef;\n  border: 0.1px solid  #d3d3d3;\n}\n\n.custom-row .row {\n  margin-bottom: 2px; /* Reduces space between rows */\n}\n\n\n.custom-row .form-group {\n  margin-bottom: 2px; /* Reduces bottom margin of form groups, affecting radio buttons */\n}\n\n.action-button {\n  border: 1px solid #ff4d4d; /* Color of your table border */\n  background-color: #e6f2ff; /* Light blue background for input fields */\n  border-radius: 5px; /* Rounded corners for the 'table' */\n}\n\n\n\nYou can find full code of ui, server, global  here"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dashboard project",
    "section": "",
    "text": "1 Introduction\nDear All,\nWelcome to the Public health Dashboard Creation Course! My name is Jinha Yoon and I will be your instructor for this course. I am a researcher and professor at Yonsei University College of Medicine, Department of Preventive Medicine, Institute of Occupational Health, and I have 10 years experience in the field of data analysis and visualization for public health.\nIn this course, we will explore the basics of R and Rstudio, the flexdashboard package, and Shiny. We will cover the various components of a dashboard, including visualizations, text, and interactivity, and we will learn how to create dynamic and interactive dashboards that allow users to explore data and drill down into specific details.\nBy the end of this course, you will have the skills and knowledge necessary to create effective dashboards using R, shiny and the flexdashboard package. Whether you are a beginner or an experienced R user, this course will provide you with a solid foundation for creating and sharing dashboards with others.\nI am looking forward to working with all of you and helping you achieve your goals. If you have any questions or concerns, please don’t hesitate to reach out to me.\nBest regards, Jinha Yoon"
  },
  {
    "objectID": "index.html#prerequisite",
    "href": "index.html#prerequisite",
    "title": "dashboard project",
    "section": "1.1 Prerequisite",
    "text": "1.1 Prerequisite\nBasic knowledge of R and the tidyverse package is a prerequisite for this course. The tidyverse package is a collection of R packages that provide a consistent and convenient interface for data manipulation, exploration, and visualization. In this course, we will use the tidyverse package to prepare and clean data, as well as to create visualizations.\nIt is recommended that students have a basic understanding of R syntax, data structures, and functions before enrolling in this course. If you are new to R, there are many online resources and tutorials available that can help you get started.\nIf you already have experience with R, but are new to the tidyverse package, it is recommended that you spend some time familiarizing yourself with the package and its various components. There are many resources available online, including tutorials and documentation, that can help you get started. I already make Data manipulation with R Course, that is related to tidyverse packages.\nOverall, having a solid understanding of R and the tidyverse package is essential for success in this course. I hope this information helps, and I look forward to seeing you in class!"
  },
  {
    "objectID": "0530-leaflet_maps_shiny.html#setting-up-your-environment",
    "href": "0530-leaflet_maps_shiny.html#setting-up-your-environment",
    "title": "11  shiny and leaflet for korea death rate",
    "section": "11.1 Setting Up Your Environment",
    "text": "11.1 Setting Up Your Environment\n1 Installing Required Packages\nBefore we begin, ensure you have the necessary R packages installed:\n\nif(!require(\"readxl\")) install.packages(\"readxl\")\nif(!require(\"tictoc\")) install.packages(\"tictoc\")\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"sf\")) install.packages(\"sf\", dependencies = TRUE)\nif(!require(\"leaflet\")) install.packages(\"leaflet\")\nif(!require(\"leafgl\")) install.packages(\"leafgl\")\nlibrary(sf)\nlibrary(leaflet)\nlibrary(leafgl)\nlibrary(readxl)\nlibrary(tictoc)\n\n\nLoading and Preparing Data\n\nFor this tutorial, I’ve uploaded a pre-processed version of the data to GitHub as an RDS (R Data Serialization) file ( same to previous chapter).\nDownload the provided preprocessed data files kdth1.rds (death rate data) and sf_tr.rds (spatial data for Korean regions) from the specified GitHub repository. Load these files into R using readRDS(). Briefly inspect the data using functions like head(), str(), or summary().\n\nkdeath1 &lt;- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/data/kdth1.rds\"\nsf_tr &lt;- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/data/sf_tr.rds\"\nif (!dir.exists(\"data\")) {dir.create(\"data\",  recursive = TRUE)}\ndownload.file(kdeath1, \"data/kdth1.rds\")\ndownload.file(sf_tr, \"data/sf_tr.rds\")"
  },
  {
    "objectID": "0530-leaflet_maps_shiny.html#create-a-shiny-app-for-interactive-visualization",
    "href": "0530-leaflet_maps_shiny.html#create-a-shiny-app-for-interactive-visualization",
    "title": "11  shiny and leaflet for korea death rate",
    "section": "11.2 Create a Shiny App for Interactive Visualization",
    "text": "11.2 Create a Shiny App for Interactive Visualization\nNow we can create a Shiny app to allow interactive visualization of the data:\n\nreusable function\n\nCreate a reusable function mapf() in a separate R script file named mapf.R (located in a ‘source’ folder). This function will generate the leaflet map based on user input:\n\nmapf = function(dzchoice, yearchoice, sexchoice){\n  rate = kdth1 %&gt;%\n    filter(cause == dzchoice, \n           year  == yearchoice, \n           sex   == sexchoice\n    )\n  sf_tr_m = sf_tr %&gt;% \n    left_join(rate, by=c(\"CTP_ENG_NM\"=\"region\")) %&gt;%\n    mutate(rate = as.numeric(rate))\n  \n  rate_colors = \n    colorNumeric(\n      palette = \"YlOrRd\",\n      domain = sf_tr_m$rate\n    )\n  label_text = sprintf(\"Region: %s, &lt;br&gt; Rate: %s\", \n                       sf_tr_m$CTP_ENG_NM, sf_tr_m$rate\n  )\n  \n  korea_lat = 36 ; korea_lng = 128\n  \n  leaflet(data = sf_tr_m) %&gt;%\n    addProviderTiles(\"CartoDB.Positron\") %&gt;%  # Adds a light-themed base map from CartoDB\n    setView(lng = korea_lng, lat = korea_lat, zoom = 7) %&gt;%\n    addPolygons(\n      fillColor = ~rate_colors(rate),\n      color = \"#444444\",   # Border color of the polygons\n      weight = 1,          # Border width\n      opacity = 1,\n      fillOpacity = 0.7,   # Fill opacity of the polygons\n      smoothFactor = 0.5,\n      highlightOptions = highlightOptions(\n        color = \"white\", \n        weight = 2,\n        bringToFront = TRUE\n      ), \n      label =  lapply(label_text, htmltools::HTML)\n    ) %&gt;%\n    addLegend(\n      pal = rate_colors, \n      values = sf_tr_m$rate\n    )\n  \n  \n}\n\n\nglobal\n\n\nif(!require(\"sf\")) install.packages(\"sf\", dependencies = TRUE)\nif(!require(\"leaflet\")) install.packages(\"leaflet\")\nif(!require(\"leafgl\")) install.packages(\"leafgl\")\nif(!require(\"shinydashboard\")) install.packages(\"shinydashboard\")\nif (!require(\"shinyjqui\")) install.packages(\"shinyjqui\")\nif(!require(shinyjs)) install.packages('shinyjs')\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(leafgl)\nlibrary(readxl)\nlibrary(tictoc)\nlibrary(shinydashboard)\nlibrary(shinyjqui)\nlibrary(shinyjs)\n\ntic()\nsf_tr = readRDS(\"data/sf_tr.rds\")\nkdth1 = readRDS(\"data/kdth1.rds\")\nsf_tr$CTP_ENG_NM %&gt;% sort()\ntoc()\n\n\ndzchoice = kdth1 %&gt;% pull(cause) %&gt;% unique()\nyearchoice= kdth1 %&gt;% pull(year) %&gt;% unique()\nsexchoice = c(\"Total\", \"Male\", \"Female\")\n\nsource(\"source/mapf.R\")\n\n\nui\n\nDesign the UI of the Shiny app:\nWe create a dashboardPage with a header, sidebar, and body. The body contains the leaflet map (leafglOutput(“map1”)) and input controls (disease, year, and gender selection) in an absolutePanel.\n\nui &lt;- dashboardPage(\n  dashboardHeader(),\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Map\", tabName = \"map1\", icon = icon(\"map\"))\n    )\n  ),\n  dashboardBody(\n    tabItems(\n      tabItem(\n        tabName = \"map1\",\n        leafglOutput(\"map1\"), \n        absolutePanel(\n          selectInput(\"dzchoice\",   \"Disease\", dzchoice), \n          selectInput(\"yearchoice\", \"Years\",   yearchoice), \n          selectInput(\"sexchoice\",  \"Gender\",  sexchoice) \n        )\n        \n        \n        )\n      )\n    )\n  )\n\n\nserver\n\nDefine how the app reacts to user input:\n\nserver &lt;- function(input, output, session) {\n  output$map1 &lt;- renderLeaflet({\n    mapf(\n      dzchoice = input$dzchoice,\n      yearchoice = input$yearchoice,\n      sexchoice = input$sexchoice\n    )\n  })\n}\n\nrenderLeaflet: Renders the map generated by the mapf function based on the values the user selects in the UI controls."
  },
  {
    "objectID": "0530-leaflet_maps_shiny.html#update-and-customizing-shiny",
    "href": "0530-leaflet_maps_shiny.html#update-and-customizing-shiny",
    "title": "11  shiny and leaflet for korea death rate",
    "section": "11.3 update and customizing shiny",
    "text": "11.3 update and customizing shiny\nIn this tutorial, we’ll take our interactive map to the next level! We’ll customize the user interface (UI) with CSS to give the app a more polished and visually appealing look. We’ll focus on:\n\nCustomizing fonts and styles.\nCreating a draggable and collapsible options panel.\nMaking the map responsive to different screen sizes.\n\n1: Setting Up and Customizing the UI\n1.1 Include Custom CSS\nCreate a file named styles.css in a www folder within your Shiny app directory. Paste the following CSS code into it\n\nCreates the appearance and hover effects for the controls panel (#controls).\n\n\n.main-header .logo {\n  font-family: \"Georgia\", Times, \"Times New Roman\", serif;\n  font-weight: bold;\n  font-size: 24px;\n}\n\n\ninput[type=\"number\"] {\n  max-width: 80%;\n}\n\ndiv.outer {\n  position: fixed;\n  top: 41px;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  padding: 0;\n}\n\n/* Customize fonts */\nbody, label, input, button, select { \n  font-family: 'Helvetica Neue', Helvetica;\n  font-weight: 200;\n}\nh1, h2, h3, h4 { font-weight: 400; }\n\n#controls {\n  /* Appearance */\n  background-color: white;\n  padding: 0 20px 20px 20px;\n  cursor: move;\n  /* Fade out while not hovering */\n  opacity: 0.65;\n  zoom: 0.8;\n  transition: opacity 500ms 1s;\n}\n#controls:hover {\n  /* Fade in while hovering */\n  opacity: 0.95;\n  transition-delay: 0;\n}\n\n/* Position and style citation */\n#cite {\n  position: absolute;\n  bottom: 10px;\n  left: 10px;\n  font-size: 12px;\n}\n\n/* If not using map tiles, show a white background */\n.leaflet-container {\n  background-color: white !important;\n}\n\n2 Modify the UI\nUpdate your ui.R file to include the custom CSS and apply the necessary changes to your UI elements:\n\nui &lt;- dashboardPage(\n  dashboardHeader(),\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Map\", tabName = \"map1\", icon = icon(\"map\"))\n    )\n  ),\n  dashboardBody(\n    tabItems(\n      tabItem(\n        tabName = \"map1\",\n        div(class=\"outer\",\n            tags$head(\n              # Include our custom CSS\n              includeCSS(\"www/styles.css\"),\n              tags$head(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\")\n            )),\n        leafglOutput(\"map1\", height=\"1000px\"), \n        absolutePanel(\n          id = \"controls\", class = \"panel panel-default\", fixed = TRUE,\n          draggable = TRUE, top = \"130\", left = \"auto\", right = \"50\", bottom = \"auto\",\n          width = \"330\", height = \"auto\",\n          HTML('&lt;button data-toggle=\"collapse\" data-target=\"#demo\"&gt;Options&lt;/button&gt;'),\n          tags$div(id='demo', class=\"collapse\",\n                   h2('interractive options'),\n          selectInput(\"dzchoice\",   \"Disease\", dzchoice), \n          selectInput(\"yearchoice\", \"Years\",   yearchoice), \n          selectInput(\"sexchoice\",  \"Gender\",  sexchoice) \n        ))\n        \n        \n        )\n      )\n    )\n  )\n\n\nCSS Inclusion: We use includeCSS(“www/styles.css”) to link our custom CSS file to the Shiny app.\nOuter Container (div.outer):\n\nThis div is positioned to fill the available space below the Shiny header and sidebar, allowing the map to occupy the entire viewport.\nIt also sets overflow: hidden to prevent content from spilling outside its boundaries.\n\nViewport Meta Tag: The\n\ntag is essential for making the app responsive on mobile devices.\nCollapsible Options:\n\nThe options panel is made collapsible using a Bootstrap collapse element. The “Options” button is used to toggle its visibility. This provides a cleaner look when the options aren’t needed.\nThe absolutePanel is made draggable using draggable = TRUE."
  },
  {
    "objectID": "0510-maps.html#leaflet-in-r",
    "href": "0510-maps.html#leaflet-in-r",
    "title": "9  Map display",
    "section": "9.1 leaflet in R",
    "text": "9.1 leaflet in R\nLeaflet is a powerful, open-source JavaScript library designed specifically for creating interactive maps on websites.\nHow it Works (very basically)\n\nLeaflet uses map tiles (small image sections) from a provider like OpenStreetMap.\nIt assembles these tiles to create a seamless map within an HTML container on a webpage.\nJavaScript code lets you customize the map’s appearance, add interactive elements, and respond to user actions.\n\nGetting Started\n\nThe easiest way to start is often with the leaflet package for R\n\n\n\n9.1.1 Leaflet in R Tutorial\n\nInstallation\n\nMake sure you have the leaflet package installed. Use the following code in your R console:\n\nif(!require(\"leaflet\")) install.packages(\"leaflet\")\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n\nBasic Map Creation\n\nHere’s a minimal example of how to create a simple Leaflet map in R:\n\nlibrary(tidyverse)\nlibrary(leaflet)\n\nleaflet() %&gt;% \n  addTiles() \n\n\n\n\n\n\nlibrary(leaflet): Loads the Leaflet package for use.\nleaflet(): Creates a new Leaflet map object.\naddTiles(): Adds the default OpenStreetMap base tiles to your map.\n\n\nkey Function\n\nHere’s a more tailored example:\n\nlibrary(leaflet)\n\nleaflet() %&gt;%\n  addTiles() %&gt;%\n  setView(lat = 37.56, lng = 126.9780,  zoom = 7.5) %&gt;%  # Seoul in Korea\n  addMarkers(lat = 37.56, lng = 126.9780, popup = \"I am Here !\")\n\n\n\n\n\n\nAdd Provider\n\nWhat are Providers?\n\nProviders are sources of map tile data. Think of map tiles as the small image squares that get pieced together to form the full map you see in Leaflet.\nEach provider offers a different visual style or type of map data. This could be standard street maps, satellite imagery, terrain maps, artistic styles, and more.\n\nCommon Providers\n\nOpenStreetMap:\n\nOpenStreetMap: The standard, crowd-sourced map style.\nOpenTopoMap: A map highlighting topographic features.\n\nCartoDB:\n\nCartoDB.Positron: A light and minimalist map.\nCartoDB.DarkMatter: A dark-themed map.\n\nEsri:\n\nEsri.WorldImagery: High-resolution satellite imagery.\nEsri.WorldStreetMap: A standard street map from Esri.\nEsri.NatGeoWorldMap: National Geographic style.\n\nStamen:\n\nStamen.Toner: Black and white stylized map.\nStamen.Watercolor: Artistic watercolor style.\nStamen.Terrain: Emphasizes terrain and elevation.\n\n\n\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\", group = 'Positron') %&gt;%\n  addProviderTiles(\"Esri.WorldImagery\", group = 'WorldImagery') %&gt;%\n  addProviderTiles(\"OpenStreetMap\", group = 'OpenStreetMap') %&gt;%\n  addLayersControl(\n    baseGroups = c('Positron','WorldImagery', 'OpenStreetMap'), \n    options = layersControlOptions(collapsed = TRUE)\n  ) %&gt;%\n  setView(lng = 127.5, 36.5, zoom = 7.5)\n\n\n\n\n\n\nMarker\n\n\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\", group = 'Positron') %&gt;%\n  addProviderTiles(\"Esri.WorldImagery\", group = 'WorldImagery') %&gt;%\n  addProviderTiles(\"OpenStreetMap\", group = 'OpenStreetMap') %&gt;%\n  addLayersControl(\n    baseGroups = c('Positron','WorldImagery', 'OpenStreetMap'),\n    options = layersControlOptions(collapsed = TRUE)\n  ) %&gt;%\n  setView(lng = 127.5, lat = 36.5, zoom = 5) %&gt;%\n  addMarkers(lng = 126.9780, lat = 37.5665, popup = \"&lt;b&gt;Seoul&lt;/b&gt;\") %&gt;% \n  addMarkers(lng = 129.0756, lat = 35.1796, popup = \"&lt;b&gt;Busan&lt;/b&gt;\") \n\n\n\n\n\n\naddMarkers(…): We’ve added multiple instances of the addMarkers function to place markers at different locations.\n\nlng and lat: Specify the longitude and latitude coordinates of each marker.\npopup: This optional argument lets you add a popup that appears when the marker is clicked. You can customize this with HTML content.\n\n\n\nAdding Circle Markers Circle markers are useful for indicating areas or regions rather than just points. Here’s how to add them:\n\n\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  setView(lng = 127.5, lat = 36.5, zoom = 7) %&gt;%\n  addCircleMarkers(lng = 126.9780, lat = 37.5665, radius = 10, color = \"blue\", popup = \"Seoul Circle\") %&gt;%\n  addCircleMarkers(lng = 129.0756, lat = 35.1796, radius = 10, color = \"red\", popup = \"Busan Circle\")\n\n\n\n\n\n\nAdding Polygons Polygons can be used to highlight specific areas on the map:\n\n\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  setView(lng = 127.5, lat = 36.5, zoom = 7) %&gt;%\n  addPolygons(\n    lng = c(126.9780, 126.9780, 129.0756, 129.0756), \n    lat = c(37.5665, 35.1796, 35.1796, 37.5665), \n    color = \"green\", \n    weight = 2, \n    fillOpacity = 0.5\n  )\n\n\n\n\n\n\nAdding Popups with HTML Content Popups can include more than just text. You can add HTML content for richer information display or hyperlink:\n\n\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  setView(lng = 127.5, lat = 36.5, zoom = 7) %&gt;%\n  addMarkers(\n    lng = 126.9780, \n    lat = 37.5665, \n    popup = \"&lt;b&gt;SEHnR &lt;br&gt; We are here &lt;/b&gt;&lt;br&gt;&lt;a href='https://sehnr.org' &gt;&lt;img src='https://sehnr.org/static/assets/img/researcher.png' width='100%'&gt;\" \n  )\n\n\n\n\n\n\nAdding GeoJSON Data GeoJSON is a format for encoding geographic data structures. You can add GeoJSON data to your map:\n\n\nif(!require(\"geojsonio\")) install.packages(\"geojsonio\")\nlibrary(geojsonio)\nlibrary(geojsonio)\nlibrary(sp)\n\n# GeoJSON data for an example region\ngeojson &lt;- '{ \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": {}, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ [ 126.9780, 37.5665 ], [ 127.9780, 37.5665 ], [ 127.9780, 36.5665 ], [ 126.9780, 36.5665 ], [ 126.9780, 37.5665 ] ] ] } } ] }'\n\n# Convert GeoJSON string to spatial object\ngeojson_sp &lt;- geojsonio::geojson_sp(geojson)\n\n# Set CRS to WGS 84\nproj4string(geojson_sp) &lt;- CRS(\"+proj=longlat +datum=WGS84 +no_defs\")\n\n# Create leaflet map\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  setView(lng = 127.5, lat = 36.5, zoom = 7) %&gt;%\n  addPolygons(data = geojson_sp, color = \"blue\", weight = 2, fillOpacity = 0.5)\n\n\n\n\n\n\nCustom Icons for Markers Custom icons can make your markers more visually appealing or informative:\n\n\nlibrary(leaflet)\n\n# Define the custom icon\nseoul_icon &lt;- makeIcon(\n  iconUrl = \"https://sehnr.org/media/post_images/books_chart.png\",\n  iconWidth = 30, iconHeight = 30\n)\n\nleaflet() %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  setView(lng = 127.5, lat = 36.5, zoom = 7) %&gt;%\n  addMarkers(\n    lng = 126.9780, \n    lat = 37.5665, \n    icon = seoul_icon, \n    popup = \"&lt;b&gt;Seoul&lt;/b&gt;\"\n  )"
  },
  {
    "objectID": "0510-maps.html#handling-shapefiles-and-visualizing-polygons-with-leaflet",
    "href": "0510-maps.html#handling-shapefiles-and-visualizing-polygons-with-leaflet",
    "title": "9  Map display",
    "section": "9.2 Handling Shapefiles and Visualizing Polygons with Leaflet",
    "text": "9.2 Handling Shapefiles and Visualizing Polygons with Leaflet\n\nInstallation and Setup First, ensure that the required packages are installed and loaded. This includes sf for handling spatial data, leaflet for creating interactive maps, and leafgl for rendering large datasets efficiently.\n\n\nif(!require(\"sf\")) install.packages(\"sf\", dependencies = TRUE)\nif(!require(\"leaflet\")) install.packages(\"leaflet\")\nif(!require(\"leafgl\")) install.packages(\"leafgl\")\nlibrary(sf)\nlibrary(leaflet)\nlibrary(leafgl)\n\n\nReading Shapefiles Assume that your shapefiles are stored in the “data” directory. Use list.files to identify the shapefiles and st_read to load a specific shapefile.\n\n\nshp.data &lt;- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/data/shp_korea.zip\"\nif (!dir.exists(\"data/shp_korea\")) {dir.create(\"data/shp_korea\",  recursive = TRUE)}\ndownload.file(shp.data, \"data/shp_korea/shp_korea.zip\")\nunzip(\"data/shp_korea/shp_korea.zip\", exdir = \"data/shp_korea\") \nfile.remove(\"data/shp_korea/shp_korea.zip\")\n\nUse list.files to identify the shapefiles and st_read to load a specific shapefile.\n\nfiles &lt;- list.files(path=\"data/shp_korea\", pattern=\"\\\\.shp$\", full.names = TRUE)\nprint(files)\n\n[1] \"data/shp_korea/ctprvn_short.shp\" \"data/shp_korea/emd_short.shp\"   \n[3] \"data/shp_korea/sig_short.shp\"   \n\n\n\nsf = st_read(\"data/shp_korea/ctprvn_short.shp\")\n\nReading layer `ctprvn_short' from data source \n  `/home/dspub/books/dashboard_project/data/shp_korea/ctprvn_short.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 17 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 746110.3 ymin: 1458756 xmax: 1387898 ymax: 2068439\nProjected CRS: Korea 2000 / Unified CS\n\n\nCRS stands for Coordinate Reference System. It is a system that uses coordinates to relate spatial data to specific locations on the earth. Different CRSs are used to project the 3D surface of the earth onto a 2D plane, which is essential for accurate mapping and spatial analysis. When you use st_crs(sf) &lt;- 5179, This ensures that the data is correctly interpreted in the context of South Korea’s specific projected coordinate system.\nEPSG:4326 is another CRS known as WGS 84 (World Geodetic System 1984). 4326 is an EPSG code for this global geographic coordinate system. EPSG:4326 uses degrees of latitude and longitude, making it ideal for global positioning and web mapping applications.\n\nst_crs(sf) &lt;- 5179\nsf_tr &lt;- st_transform(sf, 4326)\n# Add an order column for color scaling\nsf_tr$order &lt;- 1:nrow(sf_tr)\n\n\nVisualizing with Leaflet\n\nVisualize the simplified shapefile using Leaflet. Use a color palette to highlight different regions or properties.\n\n# General coordinates for Korea\nkorea_lat &lt;- 36\nkorea_lng &lt;- 128\n\n# Create a color palette based on the order\npal &lt;- colorQuantile(\"YlOrRd\", sf_tr$order, n = 9)\n\n# Create a Leaflet map\nleaflet(data = sf_tr) %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%  # Adds a light-themed base map from CartoDB\n  setView(lng = korea_lng, lat = korea_lat, zoom = 6.4) %&gt;%\n  addPolygons(\n    fillColor = ~pal(order),\n    color = \"#444444\",   # Border color of the polygons\n    weight = 1,          # Border width\n    opacity = 1,\n    fillOpacity = 0.7,   # Fill opacity of the polygons\n    smoothFactor = 0.5,\n    highlightOptions = highlightOptions(\n      color = \"white\", \n      weight = 2,\n      bringToFront = TRUE\n    )\n  )"
  },
  {
    "objectID": "0520-leaflet_maps_korea.html#download-korea-death-rate-data",
    "href": "0520-leaflet_maps_korea.html#download-korea-death-rate-data",
    "title": "10  Visualizing Korean Death Rate Data",
    "section": "10.1 download Korea Death Rate Data",
    "text": "10.1 download Korea Death Rate Data\n\nYou can download Korean Death Rate Data from KOSIS  KOSIS download \n\n\nYou can choose the death rate by province as an XLSX (Excel) file.\n\nFor this tutorial, I’ve uploaded a pre-processed version of the data to GitHub as an RDS (R Data Serialization) file.\n\nkdeath1 &lt;- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/data/kdth1.rds\"\nsf_tr &lt;- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/data/sf_tr.rds\"\nif (!dir.exists(\"data\")) {dir.create(\"data\",  recursive = TRUE)}\ndownload.file(kdeath1, \"data/kdth1.rds\")\ndownload.file(sf_tr, \"data/sf_tr.rds\")\n\nThis code checks if a “data” directory exists. If not, it creates the directory (and any necessary parent directories) using dir.create(…, recursive = TRUE). It then downloads the RDS files from GitHub and saves them in the “data” directory.\n2: Load the Data\nLoad the downloaded data into R using readRDS.\n\nkdth1 = readRDS(\"data/kdth1.rds\")\nsf_tr = readRDS(\"data/sf_tr.rds\")\n\nreadRDS is a function that reads a file saved in the RDS format and loads it into R.\n\nFilter the Data Filter the data to select death rates for a specific cause, year, and gender. In this example, we’ll select the total death rate for both sexes in 2020:\n\n\ndzchoice = kdth1 %&gt;% pull(cause) %&gt;% unique()\nyearchoice= kdth1 %&gt;% pull(year) %&gt;% unique()\nsexchoice = c(\"Total\", \"Male\", \"Female\")\n\nrate = kdth1 %&gt;%\n  filter(cause == dzchoice[1], \n         year  == yearchoice[1], \n         sex   == sexchoice[1]\n         )\n\n\nexplain\n\ndzchoice = kdth1 %&gt;% pull(cause) %&gt;% unique(): Extracts the unique causes of death from the data.\nyearchoice = kdth1 %&gt;% pull(year) %&gt;% unique(): Extracts the unique years from the data.\nsexchoice = c(“Total”, “Male”, “Female”): Defines the sex choices.\n\nrate = kdth1 %&gt;% filter(…): Filters the data to select the specific cause, year, and sex.\n\n4: Merge Geographic and Mortality Data\nWe join the geographic data with the mortality data. This will allow us to visualize the death rates on a map.\n\nsf_tr_m = sf_tr %&gt;% \n  left_join(rate, by=c(\"CTP_ENG_NM\"=\"region\")) %&gt;%\n  mutate(rate = as.numeric(rate))\n\n\nmutate(rate = as.numeric(rate)): Converts the rate column to numeric type for consistency.\n\n5: Create Color and Label Variables\nDefine color and label variables for the map:\n\nrate_colors = \n  colorNumeric(\n  palette = \"YlOrRd\",\n  domain = sf_tr_m$rate\n  )\nlabel_text = sprintf(\"Region: %s, &lt;br&gt; Rate: %s\", \n                     sf_tr_m$CTP_ENG_NM, sf_tr_m$rate\n                     )\n\n\nYlOrRd Color Palette\n\n“YlOrRd” stands for Yellow-Orange-Red. It is one of the sequential color palettes available in the RColorBrewer package, which is designed for creating visually appealing and informative color schemes for maps and other graphics. Sequential palettes are useful for data that progresses from low to high values.\n\nHow It Works in colorNumeric\n\npalette = “YlOrRd”: This specifies that the Yellow-Orange-Red palette should be used for the color scale.\ndomain = sf_tr_m$rate: This defines the range of values (the domain) for which the color scale should be created. sf_tr_m$rate is the vector of death rates, and the colorNumeric function will map these values to colors in the “YlOrRd” palette.\n\n\n6: Set Map Center\nSet the latitude and longitude for centering the map on Korea:\n\nkorea_lat = 36 ; korea_lng = 128\n\n7: Create the Map\nCreate an interactive map displaying the mortality rate:\n\nleaflet(data = sf_tr_m) %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%  # Adds a light-themed base map from CartoDB\n  setView(lng = korea_lng, lat = korea_lat, zoom = 6.4) %&gt;%\n  addPolygons(\n    fillColor = ~rate_colors(rate),\n    color = \"#444444\",   # Border color of the polygons\n    weight = 1,          # Border width\n    opacity = 1,\n    fillOpacity = 0.7,   # Fill opacity of the polygons\n    smoothFactor = 0.5,\n    highlightOptions = highlightOptions(\n      color = \"white\", \n      weight = 2,\n      bringToFront = TRUE\n    ), \n    label =  lapply(label_text, htmltools::HTML)\n  ) %&gt;%\n  addLegend(\n    pal = rate_colors, \n    values = sf_tr_m$rate\n  )"
  },
  {
    "objectID": "0520-leaflet_maps_korea.html#create-a-function-for-visualization",
    "href": "0520-leaflet_maps_korea.html#create-a-function-for-visualization",
    "title": "10  Visualizing Korean Death Rate Data",
    "section": "10.2 Create a Function for Visualization",
    "text": "10.2 Create a Function for Visualization\nFunction Definition: Combine the steps into a function for easier reuse.\n\nmapf = function(dzchoice, yearchoice, sexchoice){\n  rate = kdth1 %&gt;%\n    filter(cause == dzchoice, \n           year  == yearchoice, \n           sex   == sexchoice\n    )\n  sf_tr_m = sf_tr %&gt;% \n    left_join(rate, by=c(\"CTP_ENG_NM\"=\"region\")) %&gt;%\n    mutate(rate = as.numeric(rate))\n  \n  rate_colors = \n    colorNumeric(\n      palette = \"YlOrRd\",\n      domain = sf_tr_m$rate\n    )\n  label_text = sprintf(\"Region: %s, &lt;br&gt; Rate: %s\", \n                       sf_tr_m$CTP_ENG_NM, sf_tr_m$rate\n  )\n  \n  korea_lat = 36 ; korea_lng = 128\n  \n  leaflet(data = sf_tr_m) %&gt;%\n    addProviderTiles(\"CartoDB.Positron\") %&gt;%  # Adds a light-themed base map from CartoDB\n    setView(lng = korea_lng, lat = korea_lat, zoom = 7) %&gt;%\n    addPolygons(\n      fillColor = ~rate_colors(rate),\n      color = \"#444444\",   # Border color of the polygons\n      weight = 1,          # Border width\n      opacity = 1,\n      fillOpacity = 0.7,   # Fill opacity of the polygons\n      smoothFactor = 0.5,\n      highlightOptions = highlightOptions(\n        color = \"white\", \n        weight = 2,\n        bringToFront = TRUE\n      ), \n      label =  lapply(label_text, htmltools::HTML)\n    ) %&gt;%\n    addLegend(\n      pal = rate_colors, \n      values = sf_tr_m$rate\n    )\n}"
  },
  {
    "objectID": "0520-leaflet_maps_korea.html#create-a-shiny-app-for-interactive-visualization",
    "href": "0520-leaflet_maps_korea.html#create-a-shiny-app-for-interactive-visualization",
    "title": "10  Visualizing Korean Death Rate Data",
    "section": "10.3 Create a Shiny App for Interactive Visualization",
    "text": "10.3 Create a Shiny App for Interactive Visualization\nNow we can create a Shiny app to allow interactive visualization of the data:"
  }
]