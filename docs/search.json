[
  {
    "objectID": "0401-shiny.html#getting-started-with-shiny",
    "href": "0401-shiny.html#getting-started-with-shiny",
    "title": "6  Shiny",
    "section": "6.1 Getting Started with Shiny",
    "text": "6.1 Getting Started with Shiny\nShiny is an R package that allows for the building of interactive web applications straight from R. Whether you are a seasoned data scientist or a beginner in data analysis, Shiny brings your R data analysis to the interactive web, enabling users to interact with your data and analysis in real-time.\n\n6.1.1 Official Documentation\nhe best place to start learning about Shiny is the official Shiny website, maintained by RStudio. The official documentation provides a thorough introduction to Shiny, tutorials for beginners, articles on more advanced topics, and a gallery of Shiny applications to inspire your projects.\nYou can access the official Shiny documentation at  shiny website \nThis website is a valuable resource for anyone looking to create Shiny applications. It covers:\n\nGetting Started: A guide for your first steps in Shiny, including installation and writing your first app.\nArticles: In-depth articles covering specific aspects of Shiny, such as reactive programming, modules, and testing.\nGallery: A collection of exemplary Shiny applications that showcase what’s possible with Shiny. These examples can serve as inspiration and learning tools for your own projects.\nReference: A comprehensive reference section for Shiny functions and their usage.\n\n\n\n\n6.1.2 shiny gallery\nThe Shiny Gallery is a fantastic resource for anyone looking to explore the capabilities of Shiny apps and find inspiration for their own projects. This gallery showcases a wide range of applications created with Shiny, demonstrating the versatility and power of the framework. Each example in the gallery includes both the actual Shiny application for you to interact with and the source code behind it. This setup allows you to not only see the app in action but also to review the code to understand how it was built.\nWhether you are new to Shiny or looking to expand your skills, the Shiny Gallery is a valuable resource for learning and inspiration. You can explore various applications, see different ways of handling user input and data visualization, and get ideas for your own Shiny projects.\nFor a direct exploration of these examples, visit the Shiny Gallery.\n\n\n\n6.1.3 just try that!!!\n\nRequired Libraries\n\nBefore we start, ensure that the Shiny package is installed and loaded. Shiny is required to build and run our web application.\n\nif(!require(\"shiny\")) install.packages(\"shiny\")\n\nand the example code is following\n\n# app.R file\nlibrary(shiny)\nlibrary(datasets)\n\n# Global variables\nvars &lt;- setdiff(names(iris), \"Species\")\n\n# User Interface\nui &lt;- pageWithSidebar(\n  headerPanel('Iris k-means clustering'),\n  sidebarPanel(\n    selectInput('xcol', 'X Variable', vars),\n    selectInput('ycol', 'Y Variable', vars, selected = vars[[2]]),\n    numericInput('clusters', 'Cluster count', 3, min = 1, max = 9)\n  ),\n  mainPanel(\n    plotOutput('plot1')\n  )\n)\n\n# Server logic\nserver &lt;- function(input, output, session) {\n  # Combine the selected variables into a new data frame\n  selectedData &lt;- reactive({\n    iris[, c(input$xcol, input$ycol)]\n  })\n\n  clusters &lt;- reactive({\n    kmeans(selectedData(), input$clusters)\n  })\n\n  output$plot1 &lt;- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n      \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n\n    par(mar = c(5.1, 4.1, 0, 1))\n    plot(selectedData(),\n         col = clusters()$cluster,\n         pch = 20, cex = 3)\n    points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  })\n}\n# Run the application\nshinyApp(ui = ui, server = server)\n\nIn this exercise, you will create a Shiny application that allows for interactive k-means clustering analysis of the Iris dataset. You will write the code in a single file, app.R, and then run the application to explore how different variables and the number of clusters affect the clustering outcome.\nStep-by-Step Instructions\n\nOpen RStudio: Start by opening RStudio, your integrated development environment for R.\nCreate a New Script: Go to File &gt; New File &gt; R Script to open a new script file.\nCopy the Shiny App Code: Copy the following Shiny application code into your new R script. This code combines both the user interface and server logic into one compact script.\nSave the Script as app.R: Save the script by clicking File &gt; Save As. Name the file app.R and choose a location on your computer where you want to save it.\nRun the Shiny App: With app.R open in RStudio, click the “Run App” button in the top right corner of the script editor. This will start the Shiny application and open it in a new window or tab in your default web browser."
  },
  {
    "objectID": "0401-shiny.html#kwcs-data-preparation",
    "href": "0401-shiny.html#kwcs-data-preparation",
    "title": "6  Shiny",
    "section": "6.2 KWCS data preparation",
    "text": "6.2 KWCS data preparation\nPrior to start about shiny, I will review the tabf code. That code will download the kwcsData6th.rds file from the GitHub repository and save it as data/kwcs6th.rds on your local machine. Then, it will use the readRDS function to load the data into R as an object named dat1.\n\nrm(list=ls())\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"broom\")) install.packages(\"broom\")\nif(!require(\"devtools\")) install.packages(\"devtools\")\nlibrary(devtools)\nif(!require(\"tabf\")) install_github(\"jinhaslab/tabf\", force = TRUE)\nlibrary(tabf)\n\n\n# data download\nurl =\"https://github.com/jinhaslab/opendata/raw/3006e12f54bd2abd3cd1aac9cda807ef8e614a42/kwcs/kwcsData6th.rds\"\ndownload.file(url, \"data/kwcs6th.rds\")\n\n\ndat1 = readRDS(\"data/kwcs6th.rds\")\n\n\ndat1 = dat1 %&gt;%\n  select(\"sleepgp\", \"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\", \"AGE\",\"satisfaction\")\nlibrary(labelled)\ndat1 = remove_labels(dat1) \n\nThis code uses the %&gt;% operator from the dplyr package to filter the columns of the dat1 data frame. The select function is used to specify the columns to keep in the filtered data frame.\nThe selected columns are:\n\nvariables\n\n“sleepgp”: Sleep status group\n“wwa1gp”: Weekly working hours group\n“shortReturn”: Whether the respondent has a short return time from work or not\n“shiftWork”: Whether the respondent works shifts or not\n“njob”: Number of jobs\n“sexgp”: Sex group\n“edugp”: Education level group\n“empgp”: Employment group\n“AGE”: Age\n“satisfaction”: Work satisfaction\n\n\nAfter the data frame has been filtered, only the specified columns will remain in the data frame, and all other columns will be dropped. This can be useful for simplifying your data set and focusing your analysis on specific variables."
  },
  {
    "objectID": "0401-shiny.html#remind-table-1-for-kwcs",
    "href": "0401-shiny.html#remind-table-1-for-kwcs",
    "title": "6  Shiny",
    "section": "6.3 remind Table 1 for KWCS",
    "text": "6.3 remind Table 1 for KWCS\nCode is specifying that the variables should be stratified by the single variable “sleepgp”, and that the categorical variables are “wwa1gp”, “shortReturn”, “shiftWork”, “njob”, “sexgp”, “edugp”, and “empgp”, while the continuous variables are “AGE” and “satisfaction”. The function “tabf” is likely a custom function that generates the Table 1 summary based on these inputs. Finally, the “htmlTable” function is being used to output the results in an HTML table format, which can be easily viewed in a web browser or other software that can render HTML tables.\n\nstratas  = c(\"sleepgp\")\ncatVars = c(\"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\")\nconVars = c(\"AGE\",\"satisfaction\")\ntab1 = tabf(dat1=dat1, stratas = stratas, catVars = catVars, conVars = conVars)\ntab1 %&gt;% htmlTable(align =\"l\", rnames=FALSE) \n\n\n\n\nvariables\nvalues\n0.non distrubance\n1.sleep disturbance\np.value\n\n\n\n\nAGE\n\n46.8±12.4\n49.7±11.9\n&lt;0.001\n\n\nwwa1gp\nNever\n12222 (94.7%)\n684 (5.3%)\n&lt;0.001\n\n\n\nRarely\n12316 (94.5%)\n714 (5.5%)\n\n\n\n\nSometimes\n9112 (90.3%)\n981 (9.7%)\n\n\n\n\nOften\n3456 (82.8%)\n717 (17.2%)\n\n\n\n\nAlways\n634 (70.0%)\n272 (30.0%)\n\n\n\nsatisfaction\n\n2.1±0.5\n2.4±0.6\n&lt;0.001\n\n\nshortReturn\nnon short return\n36183 (92.5%)\n2927 (7.5%)\n&lt;0.001\n\n\n\nshort return\n1557 (77.9%)\n441 (22.1%)\n\n\n\nshiftWork\nnon shift work\n35056 (91.9%)\n3073 (8.1%)\n&lt;0.001\n\n\n\nshift work\n2684 (90.1%)\n295 (9.9%)\n\n\n\nnjob\none-job\n37471 (91.9%)\n3317 (8.1%)\n&lt;0.001\n\n\n\nnjob\n269 (84.1%)\n51 (15.9%)\n\n\n\nsexgp\nMen\n17892 (93.1%)\n1327 (6.9%)\n&lt;0.001\n\n\n\nWomen\n19848 (90.7%)\n2041 (9.3%)\n\n\n\nedugp\nuniversity or more\n19597 (92.9%)\n1502 (7.1%)\n&lt;0.001\n\n\n\nhigh school\n14943 (91.9%)\n1318 (8.1%)\n\n\n\n\nmiddle school or below\n3200 (85.4%)\n548 (14.6%)\n\n\n\nempgp\npaid-worker\n25786 (92.4%)\n2122 (7.6%)\n&lt;0.001\n\n\n\nemployer/self-employer\n2539 (91.7%)\n229 (8.3%)\n\n\n\n\nown-account worker\n8359 (90.5%)\n880 (9.5%)\n\n\n\n\nunpaind family work\n1056 (88.5%)\n137 (11.5%)\n\n\n\n\n\n\n\n6.3.1 basic structure of shiny\nThis code defines the UI and server components of a Shiny app and then runs the app using the shinyApp() function.\nIn the ui component, you define the user interface of the app using R code. This typically includes elements like input controls (e.g. sliders, text boxes, dropdown menus) and output displays (e.g. plots, tables, text).\nIn the server component, you define the server-side logic of the app. This code processes user inputs, performs calculations, and generates output for the UI to display. In the server function, you typically define reactive expressions and use Shiny’s reactive programming features to create dynamic behavior in the app.\n\nlibrary(shiny)\n\n# Define UI\nui &lt;- fluidPage(\n  # User interface components go here\n)\n\n# Define server\nserver &lt;- function(input, output) {\n  # Server-side logic and output generation go here\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\nseperate file of shiny\n\nyou can separate the UI, server, and global code into separate files in a Shiny app. This can make your code easier to organize and maintain, especially for larger apps.\nHere’s an example of how you can structure your code into separate files:\n\nui.R: This file contains the code for the user interface of the app.\n\n\nlibrary(shiny)\n\n# Define UI\nui &lt;- fluidPage(\n  # User interface components go here\n)\n\n\nserver.R: This file contains the server-side logic and output generation of the app.\n\n\nlibrary(shiny)\n\n# Define server\nserver &lt;- function(input, output) {\n  # Server-side logic and output generation go here\n}\n\n\nglobal.R: This file contains any global code that needs to be shared across the app, such as data loading or library imports.\n\n\n# Global code goes here\nlibrary(tidyverse)\ndat1 = readRDS(\"data/kwcs6th.rds\")\n\n\nrun the app"
  },
  {
    "objectID": "0401-shiny.html#communication-between-ui-server",
    "href": "0401-shiny.html#communication-between-ui-server",
    "title": "6  Shiny",
    "section": "6.4 communication between ui, server",
    "text": "6.4 communication between ui, server\nThe user interface section of a Shiny app receives user input variables and sends them to the server section for processing. The server section accepts the input variables from the user interface, applies the necessary processing and rendering steps, generates output variables, and sends them back to the user interface. Finally, the user interface receives the output variables from the server section and displays them to the user\n\nUser input: The user interacts with input widgets defined in the user interface section of the app. These input widgets can take a variety of forms, such as text boxes, sliders, and buttons.\nInput variables: When the user interacts with an input widget, an input variable is generated. This variable contains the data entered by the user, such as the text typed into a text box or the value selected from a dropdown menu.\nSending inputs to the server: The user interface section sends the input variables to the server section of the app. This happens automatically and in real-time, using reactive programming techniques.\nProcessing input variables: The server section receives the input variables from the user interface and processes them as needed. This might involve performing calculations, filtering data, or running complex algorithms.\nRendering output: Once the input variables have been processed, the server section generates output variables. These variables contain the data that will be displayed to the user, such as a plot, a table, or a text string. The server section also applies any necessary formatting or styling to the output variables.\nSending outputs to the user interface: The server section sends the output variables back to the user interface section of the app. Again, this happens automatically and in real-time, using reactive programming techniques.\nDisplaying outputs to the user: The user interface section receives the output variables from the server section and displays them to the user. This might involve rendering the output as a plot, table, or text string, depending on the specific output format of the app. The output elements in the user interface are reactive, meaning they update in real-time as the input variables are changed by the user."
  },
  {
    "objectID": "0401-shiny.html#shiny-ui-structures",
    "href": "0401-shiny.html#shiny-ui-structures",
    "title": "6  Shiny",
    "section": "6.5 shiny UI structures",
    "text": "6.5 shiny UI structures\n\nNow, we discuss an overview of the structure of the user interface (UI) section in Shiny, specifically focusing on the use of sidebarPanel, mainPanel, tabsetPanel, inputWidgets, and actionButton.\nsidebarLayout(): Creates a two-panel layout with a sidebar on the left and a main panel on the right.\nsidebarPanel(): Defines the content for the sidebar panel, which typically contains input widgets, such as sliders, dropdown menus, or text input boxes.\nmainPanel(): Defines the content for the main panel, which typically contains output elements, such as tables, plots, or text output.\ntabsetPanel(): Organizes the UI into multiple tabs, with different content displayed in each tab.\nactionButton(): Creates a button widget that the user can click to trigger an action in the app."
  },
  {
    "objectID": "0401-shiny.html#input-and-ouput",
    "href": "0401-shiny.html#input-and-ouput",
    "title": "6  Shiny",
    "section": "6.6 Input and ouput",
    "text": "6.6 Input and ouput\nThe first code chunk defines the user interface (UI) for a Shiny app. The UI consists of a text input box labeled “What is your outcome?” with a default value of “Sleep problem”, and a verbatim text output labeled “myoutput”.\nThe second code chunk defines the server-side logic for the Shiny app. Specifically, it creates a reactive expression that renders the text entered in the input box as the output.\nThe third code chunk loads a data file named “kwcs6th.rds” as a data frame called “dat1” using the readRDS() function from the tidyverse package.\n\nui &lt;- fluidPage(\n  # Create input text box\n  textInput(\"myquestion\", \"What is your outcome:\", value = \"Sleep problem\"),\n  \n  # Create output\n  verbatimTextOutput(\"myoutput\")\n)\n\n\n# Define server\nserver &lt;- function(input, output) {\n  # Define reactive expression for output\n  output$myoutput &lt;- renderPrint({\n    input$myquestion\n  })\n}\n\n\nlibrary(tidyverse)\ndat1 = readRDS(\"data/kwcs6th.rds\")\ndat1 = dat1 %&gt;%\n  select(\"sleepgp\", \"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\", \"AGE\",\"satisfaction\")\ngg = names(dat1)\n\n\nInput and server feedback\n\nThis code creates a dropdown menu for selecting the strata variable, and a table output object named “tableoutput1”.\nThe server function subsets the data to the selected strata variable using the input$strata variable and creates a table of the frequency of each category in the selected variable. The addmargins() function is used to add a row and column to the table with the totals.\n\nui &lt;- fluidPage(\n\n  # Create output\n selectInput(\"smry\", \"Select variables of summary:\", choices = gg, selected = c(\"sleepgp\")), \n \n tableOutput(\"tableoutput1\")\n)\n\n\nserver &lt;- function(input, output) {\n  # Define reactive expression for output\n  output$myoutput &lt;- renderPrint({\n    input$myquestion\n  })\n  selected_smry &lt;- reactive({input$smry})\n  output$tableoutput1 &lt;- renderTable({\n    dat1 %&gt;% select(all_of(selected_smry())) %&gt;% table() %&gt;% \n      addmargins() \n  })\n}\n\n\nlibrary(tidyverse)\ndat1 = readRDS(\"data/kwcs6th.rds\")\n\ndat1 = dat1 %&gt;%\n  select(\"sleepgp\", \"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\", \"AGE\",\"satisfaction\")\ngg = names(dat1)\n\nif the selected variable is numeric, the table() function may not be the most suitable way to summarize the data. Instead, you can use the summarize() function from the tidyverse package to calculate the mean and standard deviation of the selected variable.\n\nserver &lt;- function(input, output) {\n  # Define reactive expression for output\n\n  selected_smry &lt;- reactive({input$smry})\n  output$tableoutput1 &lt;- renderTable({\n    \n    if(is.numeric(dat1 %&gt;% pull(selected_smry()))){\n      dat1 %&gt;% summarize(mean=mean(!!sym(selected_smry())), \n                         sd=sd(!!sym(selected_smry())))\n    } else {\n      dat1 %&gt;% select(all_of(selected_smry())) %&gt;% table() %&gt;% \n      addmargins() \n    }\n  })\n}\n\n\nThis code shows a basic example of a Shiny app, and you can build on this foundation to create more complex apps with additional features. For example, you could add more input widgets to allow the user to select different subsets of data or change the analysis parameters, or you could add more output elements to display different types of visualizations or summary statistics.\n\n6.6.1 outputs from input\nIt’s important to use the correct typeOutput function in the user interface section for the type of output being displayed in the app, depending on which type of render function is used to generate the output in the server section.\nFor example, renderPlot() generates a plot output and should be paired with plotOutput() in the UI section, while renderTable() generates a table output and should be paired with tableOutput(). It’s also worth noting that renderText() can only handle character strings, while renderPrint() can handle any printed output.\nData tables are a special type of table output that allow users to page through the data or sort it, and are displayed using dataTableOutput(). important examples are shown below\n\n\n\n\n\n\n\n\nServer rendering\nassignment\nUI Output function\n\n\n\n\nrenderText()\noutput$prediction\ntextOutput(\"prediction\")\n\n\nrenderPrint()\noutput$model\ntextOutput(\"model\")\n\n\nrenderPlot()\noutput$plot1\nplotOutput(\"plot1\")\n\n\nrenderTable()\noutput$table1\ntableOutput(\"table1\")\n\n\nrenderDataTable()\noutput$dt\ndataTableOutput(\"dt\")\n\n\n\n\n\n6.6.2 Tab pannels\n\nTab pannel\n\nThe code defines the user interface (UI) for a Shiny app that contains a tabsetPanel with two tabPanels named “Summary Table” and “Table 1”. The UI includes two tabs, but neither tab has any content or input widgets\n\nui &lt;- fluidPage(\n  tabsetPanel(\n    tabPanel(\"Summary Table\"),\n    tabPanel(\"Table 1\")\n  )\n)\n\n\nNow, the “Summary Table” tabPanel includes a selectInput widget called “smry” and a tableOutput widget called “tableoutput1”, which are defined as outputs for the server function.\n\n\nui &lt;- fluidPage(\n  \n  tabsetPanel(\n    tabPanel(\"Summary Table\",\n  \n  # Create output\n  selectInput(\"smry\", \"Select variables of summary:\", choices = gg, selected = c(\"sleepgp\")), \n  \n  tableOutput(\"tableoutput1\")\n  )), \n  tabPanel(\"Table 1\")\n  \n  \n)\n\n\nMultiple input and Table 1\n\nRemind following code of Table 1. We will use following code in shiny\n\nstratas  = c(\"sleepgp\")\ncatVars = c(\"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\")\nconVars = c(\"AGE\",\"satisfaction\")\ntab1 = tabf(dat1=dat1, stratas = stratas, catVars = catVars, conVars = conVars)\ntab1 %&gt;% htmlTable(align =\"l\") \n\nfor ui, this app has two tabs: one for the Summary Table and one for the Table 1 summary. In the Summary Table tab, the user can select one or more variables from a dropdown menu called “smry”, and the app generates a summary table that shows summary statistics for the selected variables. F In the Table 1 tab, the user can select a strata variable from a dropdown menu called “stratas”, one or more categorical variables from a dropdown menu called “catVars”, and one or more continuous variables from a dropdown menu called “conVars”. The app then generates a Table 1 summary for the selected variables stratified by the selected strata variable.\n\nui &lt;- fluidPage(\n  \n  tabsetPanel(\n    tabPanel(\"Summary Table\",\n             \n             # Create output\n             selectInput(\"smry\", \"Select variables of summary:\", \n                         choices = gg, selected = c(\"sleepgp\")), \n             \n             tableOutput(\"tableoutput1\")\n    ), \n    tabPanel(\"Table 1\", \n             \n             # Create dropdown for strata variables\n             selectInput(\"stratas\", \"Select strata variable(s):\", \n                         choices = c(\"None\", names(dat1)), \n                         selected = \"sleepgp\", multiple = FALSE),\n             \n             # Create dropdown for categorical variables\n             selectInput(\"catVars\", \"Select categorical variable(s):\", \n                         choices = c(\"None\"), \n                         selected = \"wwa1gp\", multiple = TRUE),\n             \n             # Create dropdown for continuous variables\n             selectInput(\"conVars\", \"Select continuous variable(s):\", \n                         choices = c(\"None\", names(dat1)[sapply(dat1, is.numeric)]), \n                         selected = \"AGE\", multiple = TRUE),\n             \n             # Output table for Table 1\n             uiOutput(\"table1\")\n             \n    )))\n\nThe server component of the app includes reactive expressions that update the dropdown menus dynamically based on the user’s selections, as well as the “tabf” function that generates the Table 1 summary based on the selected variables and strata variable. The resulting Table 1 summary is output in an HTML table format using the “htmlTable” function from the “htmlTable” package.\n\nserver &lt;- function(input, output, session) {\n  # Define reactive expression for output\n  \n  selected_smry &lt;- reactive({input$smry})\n  output$tableoutput1 &lt;- renderTable({\n    \n    if(is.numeric(dat1 %&gt;% pull(selected_smry()))){\n      dat1 %&gt;% summarize(mean=mean(!!sym(selected_smry())), \n                         sd=sd(!!sym(selected_smry())))\n    } else {\n      dat1 %&gt;% select(all_of(selected_smry())) %&gt;% table() %&gt;% \n        addmargins() \n    }\n  })\n  \n  \n  catVars &lt;- reactive(input$catVars)\n  conVars &lt;- reactive(input$conVars)\n  \n  selectedstrata &lt;- reactive(input$stratas)\n  observe({\n    char = names(dat1)[(sapply(dat1, is.character))]\n    choices &lt;- char[char!=selectedstrata()]\n     updatePickerInput(session, \"catVars\", choices = choices, selected = \"None\")\n  })\n  \n  \n  tab1 = reactive(tabf(dat1=dat1, stratas = selectedstrata(), catVars = catVars(), conVars = conVars()))\n   output$table1 = renderUI(tab1() %&gt;% htmlTable(align =\"l\"))\n  \n}\n\n\nSidebarLayout\n\nIn the Summary Table tab, the sidebarLayout function is used to create a layout with a sidebar panel and a main panel. The selectInput function for the “smry” variable is placed in the sidebar panel, and the tableOutput function is placed in the main panel. This allows the user to select the variables to summarize in the sidebar, while the resulting table is displayed in the main panel.\n\n\nui &lt;- fluidPage(\n  \n  tabsetPanel(\n    tabPanel(\"Summary Table\",\n             sidebarLayout(     \n               sidebarPanel(\n             \n             # Create output\n             selectInput(\"smry\", \"Select variables of summary:\", choices = gg, selected = c(\"sleepgp\"))\n             ), \n             \n            mainPanel(\n              tableOutput(\"tableoutput1\")\n              )\n    )), \n    tabPanel(\"Table 1\", \n             sidebarLayout(\n               sidebarPanel(\n             # Create dropdown for strata variables\n             selectInput(\"stratas\", \"Select strata variable(s):\", \n                         choices = c(\"None\", names(dat1)), \n                         selected = \"sleepgp\", multiple = FALSE),\n             \n             # Create dropdown for categorical variables\n             selectInput(\"catVars\", \"Select categorical variable(s):\", \n                         choices = c(\"None\"), \n                         selected = \"wwa1gp\", multiple = TRUE),\n             \n             # Create dropdown for continuous variables\n             selectInput(\"conVars\", \"Select continuous variable(s):\", \n                         choices = c(\"None\", names(dat1)[sapply(dat1, is.numeric)]), \n                         selected = \"AGE\", multiple = TRUE)\n             ),\n             \n             # Output table for Table 1\n             mainPanel(\n               uiOutput(\"table1\")\n             ))\n    )\n  )\n)"
  },
  {
    "objectID": "0401-shiny.html#picker-input-and-more",
    "href": "0401-shiny.html#picker-input-and-more",
    "title": "6  Shiny",
    "section": "6.7 Picker Input and more",
    "text": "6.7 Picker Input and more\nYes, you can add the installation and library loading code for the shinyWidgets package in the global environment of your Shiny app.\n\nif(!require(\"shinyWidgets\")) install.packages(\"shinyWidgets\")\nlibrary(shinyWidgets)\n\n\nThe pickerInput function creates a dropdown menu with checkboxes for selecting multiple continuous variables. The choices argument specifies the available options for selection, and selected specifies the default selections. The options argument specifies the options for the picker input widget. Here, we’ve used pickerOptions to enable an actions box that allows the user to select/deselect all options at once.\n\nui &lt;- fluidPage(\n  \n  tabsetPanel(\n    tabPanel(\"Summary Table\",\n             sidebarLayout(     \n               sidebarPanel(\n             \n             # Create output\n             selectInput(\"smry\", \"Select variables of summary:\", choices = gg, selected = c(\"sleepgp\"))\n             ), \n             \n            mainPanel(\n              tableOutput(\"tableoutput1\")\n              )\n    )), \n    tabPanel(\"Table 1\", \n             sidebarLayout(\n               sidebarPanel(\n             # Create dropdown for strata variables\n                 pickerInput(\"stratas\", \"Select strata variable(s):\", \n                         choices = c(\"None\", names(dat1)), \n                         selected = \"sleepgp\", multiple = FALSE, \n                         options = myPickerOptions\n                         ),\n             \n             # Create dropdown for categorical variables\n             pickerInput(\"catVars\", \"Select categorical variable(s):\", \n                         choices = c(\"None\"), \n                         selected = \"wwa1gp\", multiple = TRUE, \n                         options = myPickerOptions),\n             \n             # Create dropdown for continuous variables\n             pickerInput(\"conVars\", \"Select continuous variable(s):\", \n                         choices = c(\"None\", names(dat1)[sapply(dat1, is.numeric)]), \n                         selected = \"AGE\", multiple = TRUE, \n                         options = myPickerOptions)\n             ),\n             \n             # Output table for Table 1\n             mainPanel(\n               uiOutput(\"table1\")\n             ))\n    )\n  ))\n\nThe updatePickerInput function is used to dynamically update the dropdown menu options for categorical variables based on the selected strata variable.\n\nThe function takes several arguments:\nsession: the Shiny session object inputId: the ID of the pickerInput widget to update choices: a character vector of new choices for the pickerInput widget selected: a character vector of selected choices for the pickerInput widget\n\nserver &lt;- function(input, output, session) {\n  # Define reactive expression for output\n  \n  selected_smry &lt;- reactive({input$smry})\n  output$tableoutput1 &lt;- renderTable({\n    \n    if(is.numeric(dat1 %&gt;% pull(selected_smry()))){\n      dat1 %&gt;% summarize(mean=mean(!!sym(selected_smry())), \n                         sd=sd(!!sym(selected_smry())))\n    } else {\n      dat1 %&gt;% select(all_of(selected_smry())) %&gt;% table() %&gt;% \n        addmargins() \n    }\n  })\n  \n  \n  catVars &lt;- reactive(input$catVars)\n  conVars &lt;- reactive(input$conVars)\n  \n  selectedstrata &lt;- reactive(input$stratas)\n  observe({\n    char = names(dat1)[(sapply(dat1, is.character))]\n    choices &lt;- char[char!=selectedstrata()]\n     updatePickerInput(session, \"catVars\", choices = choices, selected = \"None\")\n  })\n  \n  \n  tab1 = reactive(tabf(dat1=dat1, stratas = selectedstrata(), catVars = catVars(), conVars = conVars()))\n   output$table1 = renderUI(tab1() %&gt;% htmlTable(align =\"l\"))\n  \n}\n\nIn global, We have also defined the myPickerOptions list, which is used to customize the options for the pickerInput widget.\n\nlibrary(tidyverse)\ndat1 = readRDS(\"data/kwcs6th.rds\")\n\nlibrary(labelled)\ndat1 = dat1 %&gt;%\n  select(\"sleepgp\", \"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\", \"AGE\",\"satisfaction\")\ndat1 = remove_labels(dat1) \n\n\ngg = names(dat1) %&gt;% as.list()\n\n\nif(!require(\"devtools\")) install.packages(\"devtools\")\nlibrary(devtools)\nif(!require(\"tabf\")) install_github(\"jinhaslab/tabf\", force = TRUE)\nlibrary(tabf)\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"broom\")) install.packages(\"broom\")\n\nif(!require(\"shinyWidgets\")) install.packages(\"shinyWidgets\")\nlibrary(shinyWidgets)\n\nmyPickerOptions &lt;- list(\n  `actions-box` = TRUE,\n  `live-search` = TRUE,\n  `selected-text-format` = \"count &gt; 2\",\n  search = TRUE\n)"
  },
  {
    "objectID": "0401-shiny.html#logistic-regression-model",
    "href": "0401-shiny.html#logistic-regression-model",
    "title": "6  Shiny",
    "section": "6.8 Logistic Regression model",
    "text": "6.8 Logistic Regression model\nWe have created three pickerInput widgets to select the dependent variable, independent variable(s), and reference categories for categorical variables. The options argument for the pickerInput widgets is set to myPickerOptions, which customizes the appearance of the dropdown menus. We have also created an action button with label “Analysis Start” that the user can click to run the logistic regression model.\n\nui &lt;- fluidPage(\n  \n  tabsetPanel(\n    tabPanel(\"Summary Table\",\n             sidebarLayout(     \n               sidebarPanel(\n             \n             # Create output ----------------\n             selectInput(\"smry\", \"Select variables of summary:\", choices = gg, selected = c(\"sleepgp\"))\n             ), \n             \n            mainPanel(\n              tableOutput(\"tableoutput1\")\n              )\n    )), \n    tabPanel(\"Table 1\", \n             sidebarLayout(\n               sidebarPanel(\n             # Create dropdown for strata variables\n                 pickerInput(\"stratas\", \"Select strata variable(s):\", \n                         choices = c(\"None\", names(dat1)), \n                         selected = \"sleepgp\", multiple = FALSE, \n                         options = myPickerOptions\n                         ),\n             \n             # Create dropdown for categorical variables\n             pickerInput(\"catVars\", \"Select categorical variable(s):\", \n                         choices = c(\"None\"), \n                         selected = \"None\", multiple = TRUE, \n                         options = myPickerOptions),\n             \n             # Create dropdown for continuous variables\n             pickerInput(\"conVars\", \"Select continuous variable(s):\", \n                         choices = c(names(dat1)[sapply(dat1, is.numeric)]), \n                         selected = \"None\", multiple = TRUE, \n                         options = myPickerOptions)\n             ),\n             \n             # Output table for Table 1\n             mainPanel(\n               uiOutput(\"table1\")\n             ))\n    ), \n    tabPanel(\"Logistic Model\",\n             sidebarLayout(\n               sidebarPanel(  \n                 pickerInput(\"Dependent\", \"Dependent Variable: \", \n                             choices = c(\"None\", names(dat1)), \n                             selected = \"sleepgp\", multiple = FALSE)\n                 ,\n                 uiOutput(\"RefsChoice\"),\n                 pickerInput(\"Independent\", \"Independent Variable: \", \n                             choices = c(\"None\"), \n                             selected = c(\"wwa1gp\"), multiple = TRUE,\n                             options = myPickerOptions)\n                 ,\n                 actionButton(inputId = \"submit\", label =\"Analysis Start\"),\n                 \n               ),\n               mainPanel(tags$h3(\"model formular\"),\n                         htmlOutput(\"formular\"), \n                         htmlOutput(\"mod1\"))\n             )\n    )\n  )\n)\n\nIn server setting, First, We define the reactive expression RC, which gets the unique values of the dependent variable to use as the reference value for the logistic regression model. We then create an output called RefsChoice that uses a pickerInput widget to allow the user to select the reference category for categorical variables.\nNext, We define the reactive expression SelectedDependent which retrieves the value of the dependent variable selected by the user. We then create an observer that updates the choices available for the independent variable dropdown based on the selected dependent variable.\nWe create two output elements: formular and mod1. The formular output generates a string that displays the logistic regression model formula based on the user’s input. The mod1 output uses the glm function to fit a logistic regression model and generate the summary output using oddsTabf.\n\nserver &lt;- function(input, output, session) {\n  # Define reactive expression for output\n  \n  selected_smry &lt;- reactive({input$smry})\n  output$tableoutput1 &lt;- renderTable({\n    \n    if(is.numeric(dat1 %&gt;% pull(selected_smry()))){\n      dat1 %&gt;% summarize(mean=mean(!!sym(selected_smry())), \n                         sd=sd(!!sym(selected_smry())))\n    } else {\n      dat1 %&gt;% select(all_of(selected_smry())) %&gt;% table() %&gt;% \n        addmargins() \n    }\n  })\n  \n  \n  catVars &lt;- reactive(input$catVars)\n  conVars &lt;- reactive(input$conVars)\n  \n  selectedstrata &lt;- reactive(input$stratas)\n  observe({\n    char = names(dat1)[(sapply(dat1, is.character))]\n    choices &lt;- char[char!=selectedstrata()]\n     updatePickerInput(session, \"catVars\", choices = choices, selected = \"None\")\n  })\n  \ntab1 = reactive({\n  if (is.null(catVars())) {\n    tabf(dat1=dat1, stratas = selectedstrata(), conVars = conVars())\n  } else if (is.null(conVars())) {\n    tabf(dat1=dat1, stratas = selectedstrata(), catVars = catVars())\n  } else {\n    tabf(dat1=dat1, stratas = selectedstrata(), catVars = catVars(), conVars = conVars())\n  }\n})\n\noutput$table1 = renderUI({\n  validate(need(catVars(), \"Select variables\"))\n  tab1() %&gt;% htmlTable(align =\"l\")\n})\n\n\n\n\n   \n   \n   # logistic regression\n   ## reference value\n   RC &lt;-  reactive({ validate(\n                     need(input$Dependent, \"Dependent variable\") )\n                     dat1 %&gt;% select(input$Dependent) %&gt;% unique() %&gt;% pull(.)\n                     })\n   \n   output$RefsChoice &lt;- renderUI({\n                     pickerInput(\"Refs\", \"Odds for:\",\n                     list(`odds for` = RC()))\n                      })\n   ## independent variable\n   SelectedDependent &lt;- reactive(input$Dependent)\n   observe({\n     char2 = names(dat1)\n     choices2 &lt;- char2[char2!=SelectedDependent()]\n     updatePickerInput(session, \"Independent\", choices = choices2, selected = c(\"None\"), \n                                            options = myPickerOptions)\n   })\n   output$formular &lt;- renderUI({\n     form &lt;- HTML(sprintf(\"&lt;h3&gt; %s == '%s' &lt;br/&gt; ~ %s &lt;/h3&gt;\",input$Dependent, input$Refs  ,paste0(input$Independent, collapse=\" + \")))\n   })\n   \n  observeEvent(input$submit, {\n    output$mod1 &lt;- renderUI({\n      validate(need(input$Independent, \"Select independent variable\"))\n      f1 &lt;- sprintf(\"%s == '%s' ~ %s \",\n                    input$Dependent, input$Refs,\n                    paste0(input$Independent, collapse=\" + \"))\n      mod1 &lt;- glm(data=dat1, family=binomial(), as.formula(f1))\n      oddsTabf(mod1)\n    })\n  })\n   \n  \n}\n\nLet’s focuse on observeEvent function\n\n  observeEvent(input$submit, {\n    output$mod1 &lt;- renderUI({\n      validate(need(input$Independent, \"Select independent variable\"))\n      f1 &lt;- sprintf(\"%s == '%s' ~ %s \",\n                    input$Dependent, input$Refs,\n                    paste0(input$Independent, collapse=\" + \"))\n      mod1 &lt;- glm(data=dat1, family=binomial(), as.formula(f1))\n      oddsTabf(mod1)\n    })\n  })\n\nThe observeEvent function listens for a click on the “Analysis Start” button (input$submit) and then executes the logistic regression code within the output$mod1 render function to generate the odds ratio table. Once the table is generated, it will be displayed on the UI.\n\nThe global is same as we made.\n\nlibrary(tidyverse)\ndat1 = readRDS(\"data/kwcs6th.rds\")\n\nlibrary(labelled)\ndat1 = dat1 %&gt;%\n  select(\"sleepgp\", \"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\", \"AGE\",\"satisfaction\")\ndat1 = remove_labels(dat1) \n\n\ngg = names(dat1) %&gt;% as.list()\n\n\nif(!require(\"devtools\")) install.packages(\"devtools\")\nlibrary(devtools)\nif(!require(\"tabf\")) install_github(\"jinhaslab/tabf\", force = TRUE)\nlibrary(tabf)\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"broom\")) install.packages(\"broom\")\n\nif(!require(\"shinyWidgets\")) install.packages(\"shinyWidgets\")\nlibrary(shinyWidgets)\n\nmyPickerOptions &lt;- list(\n  `actions-box` = TRUE,\n  `live-search` = TRUE,\n  `selected-text-format` = \"count &gt; 2\",\n  search = TRUE\n)"
  },
  {
    "objectID": "0401-shiny.html#quiz",
    "href": "0401-shiny.html#quiz",
    "title": "6  Shiny",
    "section": "6.9 Quiz",
    "text": "6.9 Quiz\nMake a new tab of logistic plot model. Make a app displaying ggplot output of odds ratio with 95% confidence interval. You can use following code of OR and 95% CI plot. You should modify the code, and add that into server, and modify the UI, too. Good Luck!\n\n\nfor ggplot of OR with 95%CI\n\n\nmod1 = dat1 %&gt;%\n  glm(data=.,family=\"binomial\",formula = sleepgp == \"1.sleep disturbance\"  \n      ~ wwa1gp)\n\noddf0(mod1) %&gt;%\n  ggplot(aes(y=values, x = or)) +\n  theme_classic() +\n  geom_errorbarh(aes(xmin = ll, xmax = ul), height = 0.09, color = \"#666666\", size=0.5) +\n  geom_point(shape = 15, size = 2, color = \"#444444\")  +\n  geom_vline(xintercept = 1, color = \"#FF0000\", linetype = \"dashed\", cex =0.5, alpha = 0.5) +\n  ylab(\"\") +\n  xlab(\"Odds Ratio and 95% Confidence Interval\") +\n  theme(text = element_text(family =\"Times\"))\n\nif you want to know about such ggplot code go to  Here"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dashboard project",
    "section": "",
    "text": "1 Introduction\nDear All,\nWelcome to the Public health Dashboard Creation Course! My name is Jinha Yoon and I will be your instructor for this course. I am a researcher and professor at Yonsei University College of Medicine, Department of Preventive Medicine, Institute of Occupational Health, and I have 10 years experience in the field of data analysis and visualization for public health.\nIn this course, we will explore the basics of R and Rstudio, the flexdashboard package, and Shiny. We will cover the various components of a dashboard, including visualizations, text, and interactivity, and we will learn how to create dynamic and interactive dashboards that allow users to explore data and drill down into specific details.\nBy the end of this course, you will have the skills and knowledge necessary to create effective dashboards using R, shiny and the flexdashboard package. Whether you are a beginner or an experienced R user, this course will provide you with a solid foundation for creating and sharing dashboards with others.\nI am looking forward to working with all of you and helping you achieve your goals. If you have any questions or concerns, please don’t hesitate to reach out to me.\nBest regards, Jinha Yoon"
  },
  {
    "objectID": "index.html#prerequisite",
    "href": "index.html#prerequisite",
    "title": "dashboard project",
    "section": "1.1 Prerequisite",
    "text": "1.1 Prerequisite\nBasic knowledge of R and the tidyverse package is a prerequisite for this course. The tidyverse package is a collection of R packages that provide a consistent and convenient interface for data manipulation, exploration, and visualization. In this course, we will use the tidyverse package to prepare and clean data, as well as to create visualizations.\nIt is recommended that students have a basic understanding of R syntax, data structures, and functions before enrolling in this course. If you are new to R, there are many online resources and tutorials available that can help you get started.\nIf you already have experience with R, but are new to the tidyverse package, it is recommended that you spend some time familiarizing yourself with the package and its various components. There are many resources available online, including tutorials and documentation, that can help you get started. I already make Data manipulation with R Course, that is related to tidyverse packages.\nOverall, having a solid understanding of R and the tidyverse package is essential for success in this course. I hope this information helps, and I look forward to seeing you in class!"
  }
]